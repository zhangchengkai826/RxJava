![](项目报告-题图.png)

# Table of Content

- [Abstract](#abstract)
- [Introduction](#introduction)
- [Context View](#context-view)
  * [Base](#base)
  * [Communication Tools](#communication-tools)
  * [Rely](#rely)
  * [Development Tools](#development-tools)
- [Stakeholder Analysis](#stakeholder-analysis)
  * [Power/Interest Grid](#powerinterest-grid)
- [Development View](#development-view)
  * [Modules Structure](#modules-structure)
  * [Common Processing](#common-processing)
  * [Standardization of Design](#standardization-of-design)
  * [Standardization of Testing](#standardization-of-testing)
- [Deployment View](#Deployment-View)
- [Evolution Perspective](#evolution-perspective)
  * [Version Replacement ](#version-replacement)
  * [Difference Analysis](#difference-analysis)

# Abstract

RxJava is a Java based extension of ReactiveX. As you can see, RxJava is a kind of framework to help you finish the operations of asynchronize. What's more, it has made full use of the obervers pattern. It has a very excellent flexibility and expansibility. It aims to solve the problems about asynchronization. But actually, many users said that it was a little difficult to conquer this tool. There are also some users said it was really convenient when you have a deep understanding of this tool.

# Introduction

RxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM. ReactiveX is a library for composing asynchronous and event-based programs by using observable sequences.

It extends the observer pattern to support sequences of data and/or events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety, concurrent data structures, and non-blocking I/O. 

RxJava was originally created by its development team in 2007, and its developers developed a project in the second half of 2009, The project was a financial services application that started off life as a Silverlight project then expanded into an integration project. The developers used Rx everywhere; client side in Silverlight 3/4, and server side in .NET 3.5/4.0. They were finding bugs in the early releases and posting proposed fixes to the guys at Microsoft. They were constantly updating to the latest version. It cost the project to be early adopters, but in time the payment was worth it. Rx allowed people to massively simplify an application that was inherently asynchronous, highly concurrent and targeted low latencies. Similar workflows that you had written in previous projects were pages of code long, now with Rx were several lines of LINQ. Trying to test asynchronous code on clients (WPF/Win Forms/Silverlight) was a constant challenge, but Rx solved that too.

This chapter gives a structured overview of RxJava by providing descriptions of the various parts that compose its architecture, in order to explain the system and how it works.

# Context View

The context view shows the different relations, dependencies and interactions RXJava has with its environment. Important for the context view are the people, systems and external entities with which system interacts. The context view can be seen in the following figure and the relationship is explained in the figure1.

![FIGURE1](sa-report-assets/context-view-fig.png)FIGURE1 THE DESCRIPTION OF CONTEXT VIEW 

In order to understand this context model of RXJava, some of the external entities are explained.

## Base

RXJava is the extension of observer mode. So we also say RXJava is observable. Actually，this mode is very easy to understand. We have an observable and a subscriber. This mode can be described like this: a subscriber can subscrib an observable. For example, a switch can be an observable and a light can be the subscriber.  The light should observe the action of the switch and do the corresponding treatment, such as turn on or turn off the light. Actually, observer mode is just a frame. RxJava is based on this frame and in order to solve more complex problems, it has to work with various of operators and asynchronize operations.

## Communication Tools

RXJava uses Github and Git	for version control	to help developers collaborate and track issues related	to this library.	Contributions	in the repository come from the	RXJava development	team, as	well	as from the open-source community. In order to stay in contact with	developers and users the following communication	tools are	used: github and official website. 

## Rely

RXJava support java 6 or later version as well as its JVM languages such as Groovy, Clojure, JRuby, Kotlin. It aims to respect the customs of each kind of language. RXJava is reactive extensions for the JVM, which means it is a library for composing asynchronous and event-based programs using observable sequences for the java VM.

## Development Tools

If you want to update this library, you will feel much easier when you use Git to do the version control. What's more, because of this library is designed based on JVM, it will make your life easier if you use the following tools: Java JDK.


# Stakeholder Analysis

This section identifies the key stakeholders of RxJava and describes how they apply to the project. This will be followed by an analysis of their influence and associated levels of power and interest.

| Type | Stakeholders | Description |
| --- | --- | --- |
| Developers | Core developers, Collaborators, Any developers on GitHub | Core developers and Collaborators are actively involved in the development, maintenance and documentation of the project. They are also responsible for reviewing issues and merging pull requests from other Collaborators and GitHub users. |
| Testers | Core developers and external contributors | They test RxJava for quality and compliance and give results accordingly. They responsible for internally running the automated tests of RxJava’s testing framework. |
| Acquirers | RxJava Foundation | The foundation determines the business and technical direction of RxJava and is responsible for governance, marketing and sales. |
| Communicators | Developers and the community | GitHub is a major online platform where communicators can interact with other stakeholders, and where developers can communicate with acquisitors and other developers about issues and Suggestions for source code changes. |
| Assessors | Core developers | Assessors are stakeholders that oversee the system’s conformance to standards and legal regulation. |
| Maintainers | Developers and the community | They make decisions about the progress of the project and are responsible for all maintenance tasks. |
| Support | Collaborators | Collaborators support the development of RxJava by helping users and novice contributors. |
| Users | Learners and programmers | These users use RxJava to learn about programming or to help them program. |

## Power/Interest Grid

The following figure provides a Power/Interest grid view of the RxJava stakeholders. It classifies stakeholders according to their interest in the system and their power to influence the development of the system. Such a classification can help identify the stakeholders that have the greatest impact on the system so that their interests can be prioritized.

![](sa-report-assets/Fig1.png)

FIGURE 1: POWER/INTEREST GRID

The founders, maintainers, and community managers are the most important, directly determining the birth and development of the product. Suppliers are important on the influence scale because their opinions directly affect the direction of the product, but their interests are relatively low. Competitors, by contrast, have higher stakes and lower leverage. Beyond that are independent users and developers, who have little influence, no direct interest, and no significant role in RxJava development.

# Development View

This particular view highlights the concerns and interests of the developers and testers of the project. The different modules in the project have been identified, the file structure has been researched and important standardizations of processes are discussed.

## Modules Structure

The top layer division can be seen in *Figure 2*. Consider the actual situation, the RxJava Core and the RxJava Plugins almost surely rely on different external dependencies, since the developers of RxJava Core and RxJava Plugins may not be the same groups of people, and plugins will implement lots of features which RxJava Core does not. (That’s why it is called plugins.) The plugins are dependent on the plugin interface provided by RxJava Core to connect to the core modules. The RxJava plugin interface provides a utility class for RxJava plugin developers to inject handlers into certain standard RxJava operations. All three of these different components (RxJava Core, RxJava Plugins and External Dependencies) are assembled into the final released RxJava library. Finally, the RxJava Core also has internal dependencies which will be discussed next.

![](sa-report-assets/Fig2.png)

FIGURE 2: THE MODULE STRUCTURE VIEW OF RXJAVA

A more detailed view of modules in the source code of RxJava Core can be found in *Figure 3*. The main building blocks are the `Observables`, `Observers`, `Schedulers`, `Operators` and `Emitters` blocks, which are all used by other Java applications and/or libraries which incorporate the RxJava library. These five main components constitute the central public interface exposed by the RxJava library. 

For Observables, Observers, Operators and Emitters, they can be further divided into five main categories: `Flowable`, `Observable`, `Single`, `Completable` and `Maybe`. Each of which stands for different flowing properties and thus has its own strength and weaknesses. The core characteristic and distinctions between those five categories are shown in *Table 1*.  Note that the category Observable is different from RxJava Core’s building block Observables. RxJava Core’s building block Observables consists of the observables in call categories such as Flowable, Single, Completable or Maybe, not only observables in category Observable.

There is something confusing related to the naming conventions of classes in RxJava. The class which implements the observables of category Flowable, Observable, Single, Completable and Maybe are just called Flowable, Observable, Single, Completable and Maybe. (I believe it’s better to call them FlowableObservable, ObservableObservable, SingleObservable, CompletableObservable and MaybeObservable, as they all observables belongs to RxJava Core’s building block Observables. Although some class names such as ObservableObservable may sound a little bit weird, it reflects the real situation and is less confusing.)

For observers, operators and emitters belonging to those five main categories, the interfaces defining them are named much more reasonable. The interfaces are named in the form of ‘xxxyyy’ where ‘xxx’ stands for the category of the realized objects, which can be one of the words ‘Flowable, Observable, Single, Completable, or Maybe’, and ‘yyy’ represents the name of RxJava Core’s main building block where the realized objects live, which can be one of the words ‘Observer, Operator, or Emitter’. For instance, the class ‘MaybeObserver’ is the interface defining observers in category ‘Maybe’. There is one exception though: the interface defining observers in category ‘Flowable’ is not called ‘FlowableObserver’, instead, it is call ‘FlowableSubscriber’.

TABLE 1: THE CHARACTERISTICS OF THE MAIN FIVE CATEGORIES IN RXJAVA

| CATEGORY | CHARACTERISTICS |
| --- | --- |
| Flowable | 0.. N flows, supporting Reactive-Streams and backpressure |
| Observable | 0.. N flows, no backpressure |
| Single | A flow of exactly 1 item or an error |
| Completable | A flow without items but only a completion or error signal |
| Maybe | A flow with no items, exactly one item or an error |

Common processing parts, like `Util`, `Notification` and the RxJava `Plugin Interface`, are also used by the main blocks of source code. The behavior of source code in main blocks is annotated by [`annotations`](src/main/java/io/reactivex/rxjava3/annotations) located in the annotations folder. Finally, all plugins are accessed through the RxJava plugin interface in order to work with the core source code by means of injecting handlers to certain standard RxJava core routines.

![](sa-report-assets/Fig3.png)

FIGURE 3: A MORE DETAILED VIEW AT THE SOURCE CODE OF RXJAVA CORE

## Common Processing

Just like any other large system, RxJava has separate code modules for tasks which are common to other modules. A few of RxJava’s commonly used modules have been identified in the [`internal/util`](src/main/java/io/reactivex/rxjava3/internal/util), [`core`](src/main/java/io/reactivex/rxjava3/core) and [`plugins`](src/main/java/io/reactivex/rxjava3/plugins) folder:

* A central, common Notification class is used. It is used to represent the reactive signal types: `onNext`, `onError` and `onComplete` and holds their parameter values (a value, a Throwable, or nothing).

* Moreover, multiple utilities are made by the team to be used throughout the project. In the [`internal/util`](src/main/java/io/reactivex/rxjava3/internal/util) folder, many utilities are listed, such as [`LinkedArrayList`](src/main/java/io/reactivex/rxjava3/internal/util/LinkedArrayList.java), [`AppendOnlyLinkedArrayList`](src/main/java/io/reactivex/rxjava3/internal/util/AppendOnlyLinkedArrayList.java), [`OpenHashSet`](src/main/java/io/reactivex/rxjava3/internal/util/OpenHashSet.java), and [`VolatileSizeArrayList`](src/main/java/io/reactivex/rxjava3/internal/util/VolatileSizeArrayList.java), which are all custom and fine-tuned data structures that be easily used by other modules and improve the efficiency of binaries and readability of source code.

* Because RxJava’s plugin interface provide a utility class to inject handlers to certain standard RxJava core operations, its should be considered as common process. Many core source code make use of the plugin interface wrapper function to make some core routines easily replaced by some third-party plugins developed by external developers. The [`RxJavaPlugins`](src/main/java/io/reactivex/rxjava3/plugins/RxJavaPlugins.java) class provides the RxJava plugins developers the needed handlers to fine-tune the behavior of the RxJava library.

![](sa-report-assets/common-processing.png)

## Standardization of Design

Since RxJava is an open source library, everyone is free to contribute to the repository on GitHub. Seeing as multiple contributors are influencing RxJava, the core developers have standardized aspects of the design of the system to make it as maintainable, reliable and technically cohesive as possible. There is not a lot of information available about the general design of the platform, but the core developers have made some guidelines for new contributors to keep the overall code quality high and the licenses applicable. The most important aspects of contributing to RxJava are discussed in the [`CONTRIBUTING.MD`](CONTRIBUTING.MD) file:

* If some external developer would like to contribute code for RxJava, they can do so through GitHub by forking the repository and sending a pull request targeting the branch `3.x` which is the latest branch under active developing. 

* Contributors have to use git and have a GitHub account to be able to fork the Github repository [`ReactiveX/RxJava`](https://github.com/ReactiveX/RxJava)

* Use a text editor or IDE such as IntelliJ IDEA or Eclipse to make changes

* Optionally document changes in the RxJava documentation if it is necessary. (under [`docs`](docs) folder)

* Although not mentioned in [`CONTRIBUTING.MD`](CONTRIBUTING.MD), it is always necessary to write a solid commit message, explaining what has been done in the proposed changes.

* Before raising the first pull request, read the [`LICENSE`](LICENSE), and understand that by contributing the code, the external developers must agree to the license that all contributions are under the terms of the APLv2, and all files should be released with the Apache 2.0 license.

* If the external developers are adding a new file, the file should have a standard [`HEADER`](HEADER) where the copyright and license information are clearly stated.

* When submitting changes, the external developers should make every effort to follow existing coding conventions and styles in order to keep the code as readable as possible.

* Wait for their code to be reviewed by a RxJava core developer or other developers in the open source community.

The terminology, principles, contracts and other aspects of the design of RxJava v3 are documented in [`DESIGN.MD`](DESIGN.md). There are no concrete guidelines of using design patterns in the development of RxJava. However, as Reactive Extensions (ReactiveX) is a combination of the best ideas from the `Observer` pattern, the `Iterator` pattern, and `functional programming`, and RxJava is a Java VM implementation of ReactiveX, the RxJava library itself is indeed incorporating several good design patterns.

When examining the code, the `Factory` (the chain of operators applied to source observables are quite typical here), `Publish/Subscribe`, `Iterator` and `Singleton` design patterns have been identified. For example, the [`Flowable.java`](https://github.com/zhangchengkai826/RxJava/blob/sa-progress/src/main/java/io/reactivex/rxjava3/core/Flowable.java) and [`FlowableSubscriber.java`](src/main/java/io/reactivex/rxjava3/core/FlowableSubscriber.java) are two classes built according to the Publish/Subscribe design pattern.

![](sa-report-assets/design-patterns.png)

The implementation workflow is flexible. Core RxJava developers are allowed to commit directly into the working branch (currently is branch `3.x`), other contributors have to use pull requests. These pull requests are labelled, reviewed and discussed by developers, and will be merged into the targeting branch if necessary.

## Standardization of Testing

By standardising the test methods, technologies and conventions, the overall testing process remains consistent and has a higher pace. In this section, RxJava’s efforts to achieve this are reviewed.

The RxJava project uses `Gradle` build tool as its build tool of choice. The build script in [`build.gradle`](build.gradle) will initiates all tests and set up global settings for the test process. All new contributions provided by developers need to include two things in terms of testing. First of all, it needs to provide new unit tests, using the `JUnit` framework for any novel logic introduced. In addition, performance test and benchmarks using `JMH` (Java Microbenchmark Harness) for the new bug fixes or features should also be provided, in order to identify possible performance degradation at first spot.

Afterwards, when the developers finish their code changes and provided all the necessary tests and benchmarks, they could raise pull request in Github in order to get their contribution known and reviewed by others. RxJava uses `Travis CI` (a hosted continuous integration service used to build and test software projects hosted at GitHub) to automatically check the contributions' validity by auto rebuild the whole project in the platform provided by Travis CI.

Whenever a pull request is opened on GitHub, Travis CI might auto rebuild the project and updates the status icon on home page of the project in Github indicating whether the build is successful. The projec manager can use it to decide whether to merge this pull request. If the build process failed, the pull request will almost surely be closed by the community and the code changes will never get merged into project's main working branch, since if it is merged, it will make the whole project unbuildable.

When Travis CI rebuild the project in order to check a pull request's validity, besides the final result indicating build success or failure, it also provides complete logs of the whole build process. As a example, a build log provided by Travis CI for a RxJava pull request is presented below.

![](sa-report-assets/Travis-CI-log.jpg)

The build log provided by Travis CI can help pull request owners quickly identify the reasons causing the build failure. The developers can use the log to identify the problems in order to fix the program properly and then re-raise the pull request.

On Windows Verion 10.0.17763 with Java 1.8 Update 191, 11720 tests have been passed successfully.

![](sa-report-assets/test-results.jpg)

Finally, developers' pull requests are only merged into the project main working branch when the Travis CI build succeeds, the tests are all passed and new test material is properly provided and reviewed. Complex changes will be tested more thoroughly in different environments and levels to assure quality.

# Technical Debts

This section focuses on the technical and testing debt present inside the RxJava project. The definition of technical debt according to Techopedia is:

> Technical debt is a concept in programming that reflects the extra development work that arises when code that is easy to implement in the short run is used instead of applying the best overall solution. 

In other words, technical debts is the total time the developer team needs to pay in order to make the software project perfect.

## SonarQube Analysis

SonarQube is a platform for continuous software quality monitoring. This platform is able to analyse a large software project like RxJava in a matter of minutes. It provides the user with crucial insights about bugs, security and technical debt within the project. Running the SonarQube analysis tool on the `sa-progress` branch version of RxJava (based on `3.x` main working branch) in Github has given the following insights about technical debt. 

SonarQube reports several bugs (`119`), vulnerabilities (`only 5`!) and code smells (`3345`), ranging from `defining a constant instead of duplicating the same literal for lots of times` to `Define a constant instead of duplicating this literal "sources is null" 10 times` to `several duplicated blocks of code could be removed` (RxJava has `1757` duplicated code blocks in `1609` different files, and there are `17.2%` code are identical in the entire code base, which is obviously not a small number). 

Among all the 119 indicated bugs reported by SonarQube, `54` of them are major faults. So it seems that half of the bugs reported are necessary to fix. The other 65 bugs are labeled minor, which does not affect the main funtionalities of the RxJava library. They might be dealed with in the future when all major bugs are fixed.

The key analysis results are summerized in the following table, where all the key attributes' meanings are well documented.

| Attribute Name | Value | Description | Related Quality Attribute |
| -- | -- | -- | -- |
| Bugs | 119 | A coding error that will break the code and needs to be fixed immediately | Reliability |
| Vulnerabilities | 5 | Code that can be exploited by hackers | Security |
| Security Hotspots | 0 | Security-sensitive code that requires manual review to assess whether or not a vulnerability exists | Security |
| Debt | 172d | The estimated time it will take to fix all Code Smells | Maintainability |
| Code Smells | 3.3k | Code that is confusing and difficult to maintain | Maintainability |
| Coverage | 98.6% | The percentage of lines of code covered by tests | Coverage |
| Unit Tests | 11k | Tests that ensure your code is working properly | Coverage |
| Duplications | 17.2% | Identical lines of code | Duplication |
| Duplicated Blocks | 1.8k | The number of duplicated blocks of lines of code | Duplication |

The technical debt analysis provides a very good insight into RxJava project. SonarQube uses the SQALE methodology, which is a method to support the evaluation of source code independent of language or code analysis tools. The resulting findings include `172` days worth of technical debt. The maintainability rating of RxJava project is the highest possible rate, namely an `A`. An overview visualisation of the maintainability of RxJava project is presented below.

![](sa-report-assets/maintainability-overview.jpg)

In the above figure, each bubble represents a source code file (.java). The closer a bubble's color is to red, the higher the ratio of technical debt of that source code file is, which means the maintainability of that source code file are worse. 

The technical debts ratio is computed as `technical debts (unit: minutes) / estimated development cost (unit: minutes)`. By default, the estimated development cost is computed as `total lines of code * 30 minutes`. The higher technical debts ratio is, the harder to maintain the corresponding code.

Bubble size indicates code smell volume (The larger a bubble is, the more code smells exist in the corresponding source code file), and each bubble's vertical position reflects the estimated time to fix the code smells in the corresponding source code file. Small green bubbles on the bottom edge are best, since it means the corresponding source code file has few code smells and is easy to maintain.

# Deployment View

The deployment view is what is the environment of RxJava. It will show the hidden dependencies while using RxJava, it's hardware and software environment and lastly the required knowledge for it.

At this point in time, RxJava used some special points from Java8, so in order to use it, you must have the support of Java8. As for the development environment, any IDE which can run the Java laguage is able to support RxJava. As a result, eclipse, IDEA and other efficient IDEs all work well.

Apart from that, now RxJava has 2 versions, 1.X and 2.X. The difference between them is that the first version is more stable.

# Evolution Perspective

RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences.

##  Version Replacement 

Through out the years, RxJava has evolved a lot. And up to now, it has already 221 releases, starting from **February 5th, 2013**. It now has three versions, and the first version 1.x  is end-of-life as of **March 31, 2018**. And they have stopped adding new features to the second version 2.x, only fixing some bugs until  **December 31, 2020**.  And the version 3.x was first released on  **June 25th, 2019**.

## Difference Analysis

All versions of RxJava can be found on the GitHub repository. Compared with 1.x, Version 2.x had changed a lot especially at **API**, although the ideas of using are almost the same. It has been completely rewritten from scratch on top of the Reactive-Streams specification. The specification itself has evolved out of RxJava 1.x and provides a common baseline for reactive systems and libraries.

### Changes from 1.x to 2.x

+  Single dependency: **Reactive Streams**

     RxJava 2.0 has been completely **rewritten** from scratch on top of the **Reactive-Streams** specification, while the 1.x is **zero dependency**.

+ **API** changes

    RxJava 2.0 provides more user-friendly API and many have changed a lot. 

   + It continued to support for Java 6+ and Android 2.3+
   + Its performance of design kept increasing 
   + It support Java 8 lambda-friendly API.
   + It became non-opinion about source of concurrency.

### Changes from 2.x to 3.x

As for Version 3.x, it continue to support for Java 6+ and Android 2.3+ and does not change a lot. The changes are as follows:

+ API signature changes

    It fixed API mistakes and many limits of RxJava 2.

+ Standardized operators

    It is the same as 2.x, and for the 3.x version has just released and doesn't    has a lot explanations, some details can not be affirm.

+ Operator behavior changes
